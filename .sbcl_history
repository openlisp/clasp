0] 
2
exir
0
exit
0
(exit)
0
q
0
quit
0
(exit)
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
     (ql:quickload "grid")
     (ql:quickload "foreign-array")
(test2)
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
     (ql:quickload "grid")
     (ql:quickload "foreign-array")
(test-7-segment)
0
in-package clasp
0
(CLASP::test-solvers)
0
(CLASP::test-7-segment)
1
(CLASP::test-7-segment)
(quit)
(CLASP::test-7-segment)
o
0
quit
0
(quit)
0
3
(quit)
(asdf:operate 'asdf:load-op :clasp)
0
(asdf:operate 'asdf:load-op :clasp)
)
0
(asdf:operate 'asdf:load-op :clasp)
0
3
(asdf:operate 'asdf:load-op :clasp)
exit
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(exit)
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(test-trans-simple-capacitor )
0
(clasp:test-trans-simple-capacitor )
(clasp:test-trans-ni-simple-capacitor )
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(test-trans-ni-simple-capacitor)
0
(clasp:test-trans-ni-simple-capacitor)
0
m
0
(clasp:m)
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
1
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
0
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(clasp:get-sub-d-array m 1 1 i i)
0
(clasp:get-sub-d-array m 1 1 4 4)
0
(clasp:test-trans-ni-simple-capacitor)
(quit)
(asdf:operate 'asdf:load-op :clasp)
(ql:quickload "gsll")
(ql:quickload "grid")
(ql:quickload "foreign-array")
(clasp:test-trans-ni-simple-capacitor)
(quit)
0
1
(quit)
0
(quit)
0
(quit)
3
0
4
(quit)
4
(asdf:operate 'asdf:load-op :clasp)
1
(quit)
(asdf:operate 'asdf:load-op :clasp)
(quit)
(help 'coerce)
0
(man 'coerce)
0
(funcall #'+ 3 4]
}
)
0
(funcall #'+ 3 4)
(quit)
(clasp:simple-test-two-way-rectifier)
(quit)
0
(quit)
6
(quit)
6
(quit)
3
0
(quit)
3
4
3
6
3
(quit)
(funcall 1)
(eval 1)
0
(quit)
3
6
(quit)
4
1
(quit)
3
(quit)
(quit
)
(quit)
3
4
3
(quit)
3
~š
4
3
(+ 1 1)
(quit)
3
0
(quit)
3:
3
0
(quit)
0
(quit)
0
3
4
(quit)
3
4
š
č
6
ř3
4
3
6
8
0
4
6
7
6
(ql:quickload "gsll")
0
(load "~/quicklisp/setup.lisp")
(quit)
7
(quit)
6
0
6
(quit)
13
11
6
8
6
1
(quit)
0
           (grid:map-n-grids 
                :sources 
                  (list 
                    (list value-linear-matrices nil)  
                    (list     
                      (grid:map-grid 
                           :source (get-sub-d-array m 1 1 i i)
                           :element-function (lambda (x) (coerce (apply #'+ (mapcar #'funcall x))  'double-float)))  nil)) 
                :combination-function (lambda (a b ) (+ a b)))
0
(coerce 25  'double-float)
(coerce 0  'double-float)
(coerce nil  'double-float)
0
                           :element-function (lambda (x) (coerce (apply #'+ (mapcar #'funcall x))  'double-float)))  nil)) 1
1
(quit0
)
0
(quit)
6
8
1
(print i)
0
(print (get-sub-gd-array m 1 1 i i))
0
(quit)
6
8
6
8
(quit)
help
0
8
1
(format t "An atom: ~S~%and a list: ~S~%and an integer: ~D~%"
          nil (list 5) 6)
(quit)
8
6
5
(make-array matrix-max-index :initial-element '())
0
(make-array matrix-max-index :initial-element '())
0
(equations    
    :accessor equations
    :initform (make-array matrix-max-index :initial-element '()))
0
(quit)
5
(+ 5 5 nil 4)
0
(apply #'+  (mapcar #'funcall '(1 2 3 4)))
0
(apply #'+  (mapcar #'funcall (list 1 2 3 4)))
0
(apply #'+  (mapcar #'funcall '()))
(apply #'+  (mapcar #'funcall '() '()    ))
(apply #'+  (mapcar #'funcall '() '5    ))
(apply #'+  (mapcar #'funcall '5 '5    ))
0
(apply #'+  (mapcar #'funcall '(+) '5 '1   ))
0
(apply #'+  (mapcar #'funcall '(+ 5 1)   ))
0
(apply #'+  (mapcar #'funcall '+ 5 1)   ))
0
(apply #'+  (mapcar #'funcall '+ 5 1   ))
0
(apply #'+  (mapcar #'funcall '+ '5 '1   ))
0
(apply #'+  (mapcar #'funcall '(+ 1 1) '5 '1   ))
0
(apply #'+  (mapcar #'funcall (list '(+ 1 1) '5 '1)   ))
0
(apply #'+  (mapcar #'funcall (list (+ 1 1) 5 1)   ))
0
(apply #'+  (mapcar #'funcall (list 1 5 1)   ))
0
(apply #'+   (list 1 5 1)   ))
0
(apply #'+   (list 1 5 1)   )
(apply #'+   (list 1 5 nil 1)   )
(apply #'+  (mapcar #'funcall '()   ))
(apply #'+  (mapcar #'funcall '() '()   ))
(apply #'+  (mapcar #'funcall '() '(1)   ))
(apply #'+  (mapcar #'funcall '(1) '(1)   ))
0
(apply #'+  (mapcar #'funcall '(list 1) )   ))
1
(coerce (apply #'+  (mapcar #'funcall '())  'double-float))
0
(coerce (apply #'+  (mapcar #'funcall '()))  'double-float))
0
(coerce (apply #'+  (mapcar #'funcall '()))  'double-float)
(quit)
6
7
6
5
(make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0))))
(set a (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0)))))
0
(setf 'a (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0)))))
0
(setf (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0)))) a )
0
(setf (car x ) (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0)))))
0
(setq *x* (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0)))))
(make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0))))
(quit)
6
8
6
8
5
 (setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))
a
 (array-row-major-index a 1 2)
 (array-row-major-index a 1 3)
 (array-row-major-index a 1 1)
 (array-row-major-index a 1 0)
 (array-row-major-index a 0 0)
 (array-row-major-index a 0 1)
 (array-row-major-index a 0 2)
 (array-row-major-index a 0 3)
a
 (array-row-major-index a 0 3)
 (array-row-major-index a 1 3)
 (array-row-major-index a 1 1)
 (get-position a 1)
0
 (grid:subgrid (test-grid-double-float 'array '(3 4)) '(2 2) '(1 2))
 (grid:subgrid (grid:test-grid-double-float 'array '(3 4)) '(2 2) '(1 2))
2
 (grid:subgrid (grid:test-grid-double-float 'array '(3 4)) '(2 2) '(1 2))
1
0
 (grid:subgrid (grid:test-grid-double-float 'array '(3 4)) '(2 2) '(1 2))
1
0
 (grid:subgrid (grid:test-grid-double-float 'array '(:q53 4)) '(2 2) '(1 2))
7
(quit)
6
9
8
6
7
6
7
9
7
6
7
6
0
7
6
5
(in-package :gsl)
(LISP-UNIT:DEFINE-TEST RANDOM-NUMBER-GENERATORS
  (LISP-UNIT::ASSERT-NUMERICAL-EQUAL
   (LIST
    (LIST 999 162 282 947 231 484 957 744 540 739 759))
   (MULTIPLE-VALUE-LIST
    (LET ((RNG (MAKE-RANDOM-NUMBER-GENERATOR +MT19937+ 0)))
      (LOOP FOR I FROM 0 TO 10 COLLECT
   (sample rng :uniform-fixnum :upperbound 1000)))))
  (LISP-UNIT::ASSERT-NUMERICAL-EQUAL
   (LIST
    (LIST 0.11177622997750353d0 0.9591667949963206d0
  0.8415268011584537d0 0.9254037136795947d0
  0.27540698474059205d0 0.7093040573919677d0
  0.5541333041871588d0 0.8806957769583426d0
  0.597139396982798d0 0.7518741133398722d0
  0.9311084621265104d0))
   (MULTIPLE-VALUE-LIST
    (LET ((RNG (MAKE-RANDOM-NUMBER-GENERATOR +CMRG+ 0)))
      (LOOP FOR I FROM 0 TO 10 COLLECT (sample rng :uniform))))))
2
1
0
(in-package :gsl)
(LISP-UNIT:DEFINE-TEST RANDOM-NUMBER-GENERATORS
  (LISP-UNIT::ASSERT-NUMERICAL-EQUAL
   (LIST
    (LIST 999 162 282 947 231 484 957 744 540 739 759))
   (MULTIPLE-VALUE-LIST
    (LET ((RNG (MAKE-RANDOM-NUMBER-GENERATOR +MT19937+ 0)))
      (LOOP FOR I FROM 0 TO 10 COLLECT
   (sample rng :uniform-fixnum :upperbound 1000)))))
  (LISP-UNIT::ASSERT-NUMERICAL-EQUAL
   (LIST
    (LIST 0.11177622997750353d0 0.9591667949963206d0
  0.8415268011584537d0 0.9254037136795947d0
  0.27540698474059205d0 0.7093040573919677d0
  0.5541333041871588d0 0.8806957769583426d0
  0.597139396982798d0 0.7518741133398722d0
  0.9311084621265104d0))
   (MULTIPLE-VALUE-LIST
    (LET ((RNG (MAKE-RANDOM-NUMBER-GENERATOR +CMRG+ 0)))
      (LOOP FOR I FROM 0 TO 10 COLLECT (sample rng :uniform))))))
0
0\
2
0
(LISP-UNIT::ASSERT-NUMERICAL-EQUAL
   (LIST
    (LIST 0.11177622997750353d0 0.9591667949963206d0
  0.8415268011584537d0 0.9254037136795947d0
  0.27540698474059205d0 0.7093040573919677d0
  0.5541333041871588d0 0.8806957769583426d0
  0.597139396982798d0 0.7518741133398722d0
  0.9311084621265104d0))
   (MULTIPLE-VALUE-LIST
    (LET ((RNG (MAKE-RANDOM-NUMBER-GENERATOR +CMRG+ 0)))
      (LOOP FOR I FROM 0 TO 10 COLLECT (sample rng :uniform)))))
0
(quit)
0
(quit)
0
6
7
9
6
8
6
7
6
8
6
8
6
8
(quit)
6
8
7
8
7
6
0
4
6
8
6
7
6
(quit)
7
6
0
6
10
3
(quit)
8
(quit)
6
0
6
8
6
8
6
8
(quit)
6
7
6
8
6
7
(quit)
3
(quit)
6
7
6
5
(setf x nil)
(* 1 x )
0
(coerce x 'double-float)
0
 (coerce  (if  (eq x nil)  0.0d0  x) 'double-float)
(setf x '(1 2 3 4 5 6 7 8))
 (coerce  (if  (eq x nil)  0.0d0  x) 'double-float)
0
 (coerce  (if  (eq x nil)  0.0d0  (apply #'+  (mapcar #'funcall x))) 'double-float)
0
 (coerce  (if  (eq x nil)  0.0d0  (apply #'+  (mapcar x))) 'double-float)
0
 (coerce  (if  (eq x nil)  0.0d0  (apply #'+   x)) 'double-float)
(+ 1 1 nil 1)
0
(defun aa (x) (if(numberp x)  x 0.0d))
(aa 1)
(aa lkjdsdslkjg)
0
(aa 'lkjdsdslkjg)
0
(defun aa (x) (if(numberp x)  x 0.0d0))
(aa 'lkjdsdslkjg)
 (apply #'+ '()) 
 (apply #'+ nil) 
 (apply #'+ '(1)) 
 (apply #'+ '(1 2)) 
 (apply #'+ '(1 2 nil)) 
0
(defun aa (x) (
    ((let y (funcall x))
      if(numberp y)  y 0.0d0)))
x
(mapcar #'aa x)
(funall 1")
;
"
(quit)
2
(funall 1)
0
(funcall 1)
0
(funcall '())
0
(funcall nill)
0
(funcp x)
0
(funp x)
0
(+ 1 2 3 4 5 6)
(setf s #'func(+ 1 1))
0
(defun a ( + 1 1 ))
0.
(deffun a ( + 1 1 ))
.
1
(defun ala ( + 1 1 ))
0
(defun ala (+ 1 1 ))
0
(defun ala + 1 1 )
0
(defun ala  (+ 1 1 ))
0
(defun ala () (+ 1 1 ))
(ala)
(setf s (list 1 2 3 #'ala) )
(apply '#+ s)
0
(mapcar #funcall s)
0
(mapcar #'funcall s)
0
s
(setf d (list nil nil nil #'ala) )
(setf f (list '() '() #'ala) )
(mapcar #'funcall s)
0
(mapcar #'funcall d)
0
(mapcar #'funcall f)
0
(mapcar #'funcall f)
0
0f
0
f
d
(subseq f 1 2)
(subseq f 2 1)
0
(subseq f 2 2)
(subseq f 2 3)
(subseq f 2 4)
0
(subseq f 3 4)
0
(subseq f 3 )
(subseq f 4 )
0
(subseq f 1 )
(subseq f 0 )
(subseq f 0 2)
(subseq f 1 2)
(subseq f 1 3)
(setf g '( (list 1 2 3) (list 1 2 3)))
g
(subseq g 1 3)
(subseq g 1 1)
0
(subseq g 1 2)
(subseq g 0 1)
(make-array (list matrix-max-index matrix-max-index) :initial-element '())
(make-array (list 1 2) :initial-element '())
(make-array (list 2 2) :initial-element '())
(make-array (list 2 2) :initial-element 0.0d0)
0
(make-array (list 2 2) :initial-element 0.0d0)
m
0
(setf m (make-array (list 2 2) :initial-element 0.0d0))
m
(defmethod set-value (m row col value)
  (push  
    value
    (aref  m row col)))
(set-valute m 1 2 23
)
m
(set-value m 1 2 23)
(set-value m 1 1 23)
0
m
0
m
(set-value m 1 1 24)
m
(set-value m 0 0 '())
m
(setf m (make-array (list 2 2) :initial-element '()))
(set-value m 1 1 24)
m
(set-value m 1 1 24)
m
(setf m (make-array (list 2 2) :initial-element '(0.0d0)))
(set-value m 1 1 24)
(setf m (make-array (list 2 2) :initial-element '(0.0d0)))
(set-value m 1 1 24)
m
(subseq m 1 2 )
(subseq m 2 2 )
0
(subseq m (list 2 2 ) (list 2 2))
(subseq '( 1 2 3 4) 1 1
)
0
(subseq '( 1 2 3 4) 1 1 )
(subseq '( 1 2 3 4) 1 2 )
(subseq '((list  1 2 ) (list 3 4)) 1 2 )
(defparameter *a* #2A((1 2 3 4) (5 6 7 8) (9 10 11 12)))
(sub *a* 1 t)
0
(defmethod sub ((array array) &rest ranges)
           (declare (optimize debug (speed 0)))
  (with-range-indexing (ranges (array-dimensions array) next-index
                               :end? end?
                               :range-dimensions dimensions)
    (let ((result (make-array (coerce dimensions 'list)
                              :element-type
                              (array-element-type array))))
      (iter
        (until end?)
        (for result-index :from 0)
        (setf (row-major-aref result result-index)
              (row-major-aref array (next-index))))
      result)))
              (row-major-aref array (next-index))))
0
(sub *a* 1 t) ;
3
0
(sub *a* 1 t) ;
0
(sub *a* (1 . 2) t) ;
0
(sub *a* #(-2 -1) #(-2 -1))
0
*a*
3
0
(quit)
10
(quit)
0
1
9
6
8
6
8
6
3
(quit)
6
5
(push "." asdf:*central-registry*)
(push (truename "../") asdf:*central-registry*)
(push (truename "./") asdf:*central-registry*)
(asdf:load-system :clasp)
3
(quit)
5
(push (truename "./") asdf:*central-registry*)
(asdf:load-system :clasp)
2
(asdf:load-system :clasp)
3
(asdf:load-system :clasp)
0
(quit)
3
6
9
0
1
9
(quit)
8
9
6
5
(not true)
0
(not 'true)
(not 1)
(not 2)
(not 'false)
(not nil)
(quit)
6
4
6
8
6
10
7
(setf *x* 5)
(defsetf xy (x y z) (store)
   `(+ ,store ,x ,y ,z))
(setf (xy 1 1 1) *x*)
*x*
(defsetf zy (x y z) (store)
   (+ store x y z))
(setf (zy 1 1 1) *x*)
0
(setf (xy 1 1 1) *x*)
(+ *x* 1 1 1)
`(+ ,*x* ,1 ,1 ,1)
(+ ,*x* ,1 ,1 ,1)
0
`(+ *x* ,1 ,1 ,1)
(defsetf vy (x y z) (store)
   `(+ store ,x ,y ,z))
(setf (vy 1 1 1) *x*)
0
(defvar *xz* 5)
(setf (xy 1 1 1) *xz*)
(setf (zx 1 1 1) *xz*)
0
(setf (vx 1 1 1) *xz*)
0
(setf (zy 1 1 1) *xy*)
0
(setf (zy 1 1 1) *x*)
0
(not 2)
(quit)
8
(quit)
8
(funcall #'+ 1 1)
(funcall #'+ 1 (+ 1 1))
(+ 1 1 )
(+ 1 #'(+ 1 1) )
0
(defun x () (+ 1 1))
x
0
(x)
(+ 1 (x))
(max 1 2 )
(setf a (make-array 0 :initial-element 0.0d0 :adjustable t  ))
s
0
(setf a (make-array 0 :initial-element 0.0d0 :adjustable t  ))
(setf *a* (make-array 0 :initial-element 0.0d0 :adjustable t  ))
*a*
(vector-push 1 *a*)
0
(setf *a* (make-array 1 :initial-element 0.0d0 :adjustable t ))
(vector-push 1 *a*)
0
(setf *a* (make-array 0 :initial-element 0.0d0 :adjustable t  ))
(adjust-array *a* 5)
(quit)
9
8
7
